{"name":"csvgrep","tagline":"Easy and funny searches on text delimited files","body":"**csvgrep** is a command line program which enables users to execute searches on text delimited files using a rudimentary *query language*.\r\nIts *query language* is very bounded to simplicity and expressivity (in order to be easily comprehensible).\r\nIt is simple and easy-to-run that **csvgrep** is committed to be.\r\nIt aims at replacing both grep and awk when you are challenged to retrieve information of a text delimited file based on the content of a specific field (or column), you can get what you want using the semantic already presented into the file's underlying structure.\r\nIt is a safe pair of hands to quickly and precisely gather the information you need from a bunch of text files.\r\n\r\n<!--\r\nHere it goes a few comparisons with unix commands showing how **csvgrep** can safe your time and your brain and I dare say you will have fun using it.\r\n\r\n\r\nTask description | Unix command | csvgrep |\r\n---|---|---\r\nPrint columns 1,2,4,6 of a csv file | `awk 'BEGIN{OFS=\",\"} {print $1,$2,$4,$6}'` | `csvgrep '$1;$2;$4;$6'`\r\nPrint the second and fifth columns if <br/> first column begins with *Doe* of a pipe delimited file | `awk 'BEGIN{OFS=\"|\"} $1 ~ /^Doe/ {print $2,$5}'` | `csvgrep -I='|' '$1 eq /^Doe/; $2 ; $5'`\r\nPrint `Email-column` if `Name-column` <br/> begins with *Doe* | `-` | `csvgrep '${Name} ne /^Doe/; ${Email}'`\r\nCheck if the number of input columns <br/> remain constant | `awk 'NF == 1 {l=NF} NF > 1 {if (l!=NF) print NR}'` | `csvgrep -C '@header $NR == 1'`\r\n\r\nThese examples are a great deal far from the real world tasks you are going to face, but despite its simplicity they may give you a good idea on how **csvgrep** can help you.\r\n\r\n**csvgrep** can do this and much more. So, what are you waiting for? Don't waste your time! Give **csvgrep** a try, I am bounded to believe that it will help you.\r\n\r\n\r\n**Author**\r\n:\tWilson Freitas -- [http://aboutwilson.net](http://aboutwilson.net)\r\n\r\n**csvgrep's project site**\r\n:\t[http://code.google.com/p/csvgrep/](http://code.google.com/p/csvgrep/)\r\n\r\n-->\r\n\r\n<!-- **csvgrep** came up after a thousand trials to extract useful information from csv files using grep and awk, it's started as a few lines of perl code and grew up until reach the age of being publicly released.\r\nI'm not a prolific perl developer so **csvgrep** has reached a size where I can't handle it anymore.\r\nIt's an on-going project, so feel free to contribute with suggestions, the more you contribute, the greater work we have.\r\nI am sure to keep **csvgrep** simple enough to be executed from the command line doing more tough tasks with less effort. -->\r\n\r\n\r\n## Using **csvgrep**\r\n\r\n\r\nSimply type `csvgrep -h` to exhibit all the **csvgrep**'s options:\r\n\r\n\tUsage: csvgrep [OPTIONS] CODE [FILE]\r\n\r\n\tOPTIONS:\r\n\t\t-a\t\t[print-all] prints all fields, except with @hide\r\n\t\t-C\t\t[check] checks whether the number of columns is constant\r\n\t\t-c\t\t[close] puts one delimiter at the end of each output line\r\n\t\t-IS\t\t[input-delimiter] sets the input delimiter\r\n\t\t-OS\t\t[output-delimiter] sets the output delimiter\r\n\t\t-SS\t\t[io-delimiter] sets input and output delimiters\r\n\t\t-f\t\t[filename] prints input filename\r\n\t\t-N\t\t[number] prints line numbers\r\n\t\t-p\t\t[print-headers] prints headers\r\n\t\t-s\t\t[headers-only] prints only headers\r\n\t\t-u\t\t[unquote] unquote output fields\r\n\t\t-v\t\t[verbose] verbose mode on\r\n\t\t-V\t\t[version] prints csvgrep's version\r\n\t\t-h\t\t[help] prints this message\r\n\r\n\t---\r\n\tVersion 1.0.0\r\n\tMantained by Wilson Freitas\r\n\thttp://code.google.com/p/csvtools/\r\n\r\n\r\nThe `CODE` above stands for the expressions used by **csvgrep** to filter the desired content.\r\nThese expressions will be discussed in detail in the next sections, we are going to start with several real world examples focusing on the understanding of each of the **csvgrep**'s features.\r\n\r\n\r\n### The way **csvgrep** processes files\r\n\r\n\r\n**csvgrep** processes a file exactly the same way grep does, line by line.\r\nOnce we are expecting structured files, they must be structured in columns and also have to have a delimiter separating columns inside the file.\r\nDespite the file contains columns, when we are processing a line we are dealing with fields, because when we broke the file into lines each line is split into fields.\r\nThese are the components that usually appear while a file is being processed by **csvgrep**.\r\n\r\n\r\n### The basic\r\n\r\n\r\nAs said before, **csvgrep** works pretty much like the well known `grep` command, so you have text delimited lines and want translate it into useful information.\r\nIt's simple like that, that's the **csvgrep**'s purpose, filter content on text delimited files.\r\nBut where is the difference between **csvgrep** and `grep`? \r\nSince the file is structured in columns **csvgrep** can filter it based on the content of a specific column.\r\nConsidering the file `contacts.csv`\r\n\r\n\t$ cat contacts.csv \r\n\tName, Email, Notes, IM, Phone\r\n\tWilson, wilson@popstar.com, smart guy, wndf, 555-5555\r\n\tLorie Cabucio, lorie@lovestory.com, Hot, lolo, 555-5435\r\n\tJeckill, jeck@monster.com, , dr.jeckill,\r\n\tNando, nando@nano.com, quant guy, nando,\r\n\tRafaela, rafa@popstar.com, the girl with the dragon tattoo, rafa, 676-9876\r\n\tAndrea Martins, andy@popstar.com, likes Dave Mathews Band, andy, 576-0912\r\n\r\nThis file is structured in columns and may represent a contact list where the first line has the header (with the name of each field) and the following lines have valuable information, also organized in columns.\r\nIn order to obtain the complete list of names we do\r\n\r\n\t$ csvgrep '$1' contacts.csv\r\n\tName\r\n\tWilson\r\n\tLorie Cabucio\r\n\tJeckill\r\n\tNando\r\n\tRafaela\r\n\tAndrea Martins\r\n\r\nThe expression `$1` tells **csvgrep** to print the first column of `contacts.csv` and here we have an important thing being assumed.\r\nIn that example we assumed that the delimiter used into `contacts.csv` is a single comma (`,`), if it didn't, **csvgrep** would print the whole file.\r\nFor example, if we had other file called `contacts2.csv`, using `|` as delimiter, we would get the following output.\r\n\r\n\t$ cat contacts2.csv \r\n\tName| Email| Notes| IM| Phone\r\n\tWilson| wilson@popstar.com| smart guy| wndf| 555-5555\r\n\tLorie Cabucio| lorie@lovestory.com| Hot| lolo| 555-5435\r\n\tJeckill| jeck@monster.com| | dr.jeckill|\r\n\tNando| nando@nano.com| quant guy| nando|\r\n\tRafaela| rafa@popstar.com| the girl with the dragon tattoo| rafa| 676-9876\r\n\tAndrea Martins| andy@popstar.com| likes Dave Mathews Band| andy| 576-0912\r\n\t\r\n\t$ csvgrep '$1' contacts2.csv \r\n\tName| Email| Notes| IM| Phone\r\n\tWilson| wilson@popstar.com| smart guy| wndf| 555-5555\r\n\tLorie Cabucio| lorie@lovestory.com| Hot| lolo| 555-5435\r\n\tJeckill| jeck@monster.com| | dr.jeckill|\r\n\tNando| nando@nano.com| quant guy| nando|\r\n\tRafaela| rafa@popstar.com| the girl with the dragon tattoo| rafa| 676-9876\r\n\tAndrea Martins| andy@popstar.com| likes Dave Mathews Band| andy| 576-0912\r\n\r\nSo, for this file, we need to specify the input delimiter using the `-I` option.\r\n\r\n\t$ csvgrep -I'\\|' '$1' contacts2.csv \r\n\tName\r\n\tWilson\r\n\tLorie Cabucio\r\n\tJeckill\r\n\tNando\r\n\tRafaela\r\n\tAndrea Martins\r\n\r\nNote that since input separator is interpreted as a regular expression in Perl, so if we use `|` as a delimiter it must be escaped `\\|`.\r\nThe default delimiter for both input and output is the comma character (`,`).\r\n\r\nIf we wanted to print also the second column we could simply add `$2` to our expression to have it done.\r\nTherefore, when we write the expression, what we do is define which columns we want to print and this behavior reinforces the idea of being-like-grep.\r\nThe columns into the expression are delimited by the semicolon character (`;`).\r\n\r\n\t$ csvgrep '$1;$2' contacts.csv \r\n\tName,Email\r\n\tWilson,wilson@popstar.com\r\n\tLorie Cabucio,lorie@lovestory.com\r\n\tJeckill,jeck@monster.com\r\n\tNando,nando@nano.com\r\n\tRafaela,rafa@popstar.com\r\n\tAndrea Martins,andy@popstar.com\r\n\r\nAt this point we can see that the expression or either, the code, is formed by references to columns delimited by semicolons.\r\nSo, once you wanted to print the other columns all you have to do is to declare their references.\r\nIf you put a reference to an inexistent column, don't worry, **csvgrep** won't go off on you, an empty column is printed.\r\nFor example, we know `contacts.csv` has 5 columns, so if we try to print the column `$10` between `$1` and `$2`, we get the following result\r\n\r\n\t$ csvgrep '$1;$10;$2' contacts.csv \r\n\tName,,Email\r\n\tWilson,,wilson@popstar.com\r\n\tLorie Cabucio,,lorie@lovestory.com\r\n\tJeckill,,jeck@monster.com\r\n\tNando,,nando@nano.com\r\n\tRafaela,,rafa@popstar.com\r\n\tAndrea Martins,,andy@popstar.com\r\n\r\nIt doesn't make much sense now but who knows someday it might be useful, perhaps as placeholder generator, think about and if you figure out something, please tell me.\r\n\r\nIn the end, sometimes you may want to print all columns and it can be done through the option `-a`.\r\nI confess that it seems to be useless unless you apply a filter to at least one column, but if you want to change the file delimiter, it can be useful.\r\nConsidering we intend to use semicolon (`;`) instead of comma (`,`),\r\nthe whole file could be processed with the following command:\r\n\r\n\t$ csvgrep -a -O';' '' contacts.csv\r\n\tName;Email;Notes;IM;Phone\r\n\tWilson;wilson@popstar.com;smart guy;wndf;555-5555\r\n\tLorie Cabucio;lorie@lovestory.com;Hot;lolo;555-5435\r\n\tJeckill;jeck@monster.com;;dr.jeckill;\r\n\tNando;nando@nano.com;quant guy;nando;\r\n\tRafaela;rafa@popstar.com;the girl with the dragon tattoo;rafa;676-9876\r\n\tAndrea Martins;andy@popstar.com;likes Dave Mathews Band;andy;576-0912\r\n\r\nI know it appears too much simple and of course it could be easily done with grep, fortunately that's the simpler case.\r\n**csvgrep** handles quoted fields and in such cases it is a pain to change the delimiters when they are supposed to appear inside a quoted field.\r\nTake a look at the example below:\r\n\r\n\t$ cat quoted.csv \r\n\tName, Comment\r\n\tHyde, \"The guy who didn't sleep, do you believe\"\r\n\tLoren, \"The power, the strength, the energy what was left to us\"\r\n\t\r\n\t$ csvgrep '$2' quoted.csv \r\n\tComment\r\n\t\"The guy who didn't sleep, do you believe\"\r\n\t\"The power, the strength, the energy what was left to us\"\r\n\t\r\n\t$ csvgrep -a '' quoted.csv \r\n\tName,Comment\r\n\tHyde,\"The guy who didn't sleep, do you believe\"\r\n\tLoren,\"The power, the strength, the energy what was left to us\"\r\n\t\r\n\t$ csvgrep -a -O: '' quoted.csv \r\n\tName:Comment\r\n\tHyde:The guy who didn't sleep, do you believe\r\n\tLoren:The power, the strength, the energy what was left to us\r\n\r\nNote that\r\n\r\n- The file was correctly parsed, even with delimiters inside quoted fields.\r\n- The fields which contain the delimiter inside were printed surrounded with the quotation marks. If we wanted to unquote the fields we should use the `-u` option (unquote).\r\n- An empty parameter was given.\r\nThat is the expression parameter and since no filter is being applied it goes empty. You can also declare a reference to a column, but it would be ignored because of the `-a` option use. It seems a little weird or even unnecessary, but that's the way it is.\r\n\r\nAs we could see **csvgrep** is extremely simple to use and offers a lot of ways for solving annoying problems.\r\nOn next sessions we will look deeply at **csvgrep**'s syntax and its functionalities.\r\n\r\n### **csvgrep** expression\r\n\r\nWe saw that after its command-line options **csvgrep** receives one string delimited by single quotation marks (`'`).\r\nThis parameter is the expression, or either, the code which tells to **csvgrep** what to do.\r\nThis expression contains a list of rules separated by semicolons and each rule is formed by a statement that may be defined under the following pattern:\r\n\r\n\t[EXP-FUNC] REFERENCE [EXP-OP EXP-VALUE]\r\n\r\nwhere\r\n\r\n- `REFERENCE`: a *reference* in **csvgrep** is a variable which either refers to a field in a row or has its own value as we will see further is the situation of the *special references*. The section on [References][csvgrepReferences] below explains detailedly its use.\r\n- `EXP-FUNC`: are *expression function* that are flags attached to a rule in order to affect the way it works. Details on section [Expression functions][csvgrepExpressionFunctions].\r\n- `EXP-OP`: are the *expression operator*, since the intent is to process the file interacting with its fields, the **csvgrep**'s operators offers different ways for achieving that target. A complete list of operators can be found at section [Operators][csvgrepOperators].\r\n- `EXP-VALUE`: once we use an operator we must pass it one value, so the *expression value* is the content defined by users in order to find the desired content. An explanation about this is on the same section of [Operators][csvgrepOperators].\r\n\r\nSo **csvgrep** has these 4 entities and we will see further how easy is to define them for filtering files content.\r\nOnce understood these entities we will be able to define properly the rule, that in its essence is a boolean statement, so it's valued to true or false.\r\nIf all rules in the expression are true the line is printed otherwise it isn't so.\r\nThe next sections will go into details in order to clarify the usage of the expression and its components.\r\n\r\n#### References\r\n\r\n\r\nThe reference is the most important component of the rule.\r\nWhen we declare a reference we are telling to **csvgrep** what we is important for us and what we want to see at the output.\r\nReferences are declared starting with a `$` followed by:\r\n\r\n- a number (`$N` numbered references)\r\n- the name of column surrounded with curly braces (`${Column Name}` named references)\r\n- an identifier as in case of the special references that are variables updated while the lines are being processed.\r\n\r\n\r\nNumbered references\r\n:\tThe numbered references start with `$1` which indicates the first column and go to infinity since **csvgrep** doesn't go off on you for using an invalid numbered references.\r\n:\tThe reference `$0` indicates the whole line being processed.\r\n\r\nNamed references\r\n:\tThese references must match exactly the column name inside the curly braces.\r\nFor example, the reference `${Email}` represents the column in which the header has a field that matches `Email`.\r\n:\tWe will see soon that the header must be defined with `@header` to properly use named references.\r\n:\tOnce defined the header you can still used numbered references.\r\n\r\nSpecial references\r\n:\tCan be considered runtime-variables that are alive during the file processing and are ready for being consumed.\r\n:\t`$NR` is the number of the line currently being processed. The lines start in 1.\r\n:\t`$NF` is the number of fields in the current line.\r\n:\t`$#{.}` or `$#N` evaluates to the length of the referenced text.\r\n:\t`$?{.}` or `$?N` evaluates the rule to false if the reference is an empty string, values 0.0 or equals `/^false$/i`\r\n\r\n<!-- :\t`$$N` are *header references* which references the header field of the numbered column `N`. For example, `$$1` references the header name of the column 1. -->\r\n\r\n\r\n#### Operators\r\n\r\n\r\nThe operators are used to compare a field to a user defined value (expression value) for getting the rule evaluated as it does a boolean statement.\r\nAt this moment the expression value cannot be a reference, it only accepts the types handled by **csvgrep**.\r\n**csvgrep** can handle 2 different types of variables: strings and numbers; and each type has its own set of operators.\r\nAs defined on previous section, the reference might be followed by an operator and by an expression value, always in this order.\r\nWe cannot put the expression value before the operator, it won't work.\r\nSo, the expression values can be defined as:\r\n\r\n- simple text surrounded with double quotation marks `\"\"`\r\n- regular expression delimited by `//`\r\n- numbers since it matches any decimal number pattern\r\n- shell command surrounded with ` `` ` that is processed and the result is interpreted as text \r\n\r\nInternally both `\"\"` and `//` are converted to regular expressions.\r\nNow we will see the operators and some examples on how to use them.\r\n\r\nString operators\r\n:\t`eq`: evaluates to true if the field matches the regular expression\r\n:\t`ne`: evaluates to true if the field doesn't match the regular expression\r\n:\t`in`: evaluates to true if the text contains the field\r\n\r\nNumeric operators\r\n:\t`==`: equals\r\n:\t`!=`: not equals\r\n:\t`>` : greater than\r\n:\t`>=`: greater than or equals to\r\n:\t`<` : less than\r\n:\t`<=`: less than or equals to\r\n\r\n\r\n#### Expression Functions\r\n\r\n\r\nSometimes you want that one specific rule behaves in a different way than just being a boolean statement.\r\nFor achieving this target **csvgrep** uses expression functions that are just flags defined into a rule.\r\nUntil now we have only 2 expression functions, so we are accepting suggestions.\r\n\r\nExpression functions\r\n:\t`@hide` is used to omit the field at the output\r\n:\t`@header` is used to specify the header, when it is present in a rule, this rule is used to match the header. A common use is `@header $NR == 1` telling **csvgrep** that the header is in the first line.\r\n\r\n\r\n### Using **csvgrep**\r\n\r\nLet's get back to our `contacts.csv` and now we want to use the header for defining columns.\r\nTo do so we simply use:\r\n\r\n\t$ csvgrep '@header $NR == 1; ${Name}' contacts.csv \r\n\tWilson\r\n\tLorie Cabucio\r\n\tJeckill\r\n\tNando\r\n\tRafaela\r\n\tAndrea Martins\r\n\r\n\r\nNote that I use `${Name}` to refer to the column Name and the header line is no longer printed.\r\nIf we wanted to print the header we should use the option `-p`.\r\nIf I try to refer to a field using its name without to specify how to find the header (with `@header`), **csvgrep** raises a fatal error message.\r\nThe reference `$NR` is valued to the current line number (it is similar to NR special variable in AWK), so we are informing that the header is in the first line.\r\n\r\n\t$ csvgrep '${Name}' contacts.csv \r\n\tFatal: The @header field must be defined at ../csvgrep.pl line 160, <INPUT_FILE> line 1.\r\n\r\n<!-- *First lesson*: To refer to a column using its own name you need to show how to find the name, so forth, we need to specify how to find the header line. -->\r\n\r\nWe can define the header using other expressions\r\n\r\n\t$ csvgrep '@header $1 eq \"Name\" ; ${Name}' contacts.csv\r\n\tWilson\r\n\tLorie Cabucio\r\n\tJeckill\r\n\tNando\r\n\tRafaela\r\n\tAndrea Martins\r\n\r\nBut it's always important to be consistent with the header definition because the header is reset each time the header-rule is true.\r\n\r\nWe can go forward and see an example where a boolean expression is used to _grep_ file's contents based on its columns, that's the most common use to **csvgrep**, at least in my opinion.\r\nLet's find the email of a girl with the name *Lorie*:\r\n\r\n\t$ csvgrep '@header $NR == 1; ${Name} eq \"Lorie\" ; ${Email}' contacts.csv\r\n\tLorie Cabucio,lorie@lovestory.com\r\n\r\n<!-- wiki:comment>\r\nThe quoted string is treated as a regular expression, so to match the exact text is needed to wrap the text with `^$`, indicating the full string referenced by `${Email}`.\r\n</wiki:comment -->\r\n\r\nSince **csvgrep** compiles the quoted text as a Perl regular expression all types of regular expressions supported by Perl can be used within **csvgrep**.\r\n\r\nWe also have the operator `ne` (that negates the operator `eq`) and we can use it to find the contacts with non-empty phone number.\r\n\r\n\t$ csvgrep '@header $NR == 1; ${Name} ; ${Phone} ne \"^$\"' contacts.csv \r\n\tWilson,555-5555\r\n\tLorie Cabucio,555-5435\r\n\tRafaela,676-9876\r\n\tAndrea Martins,576-0912\r\n\t\r\n\t$ csvgrep '@header $NR == 1; ${Name} ; ${Phone} eq \"^$\"' contacts.csv \r\n\tJeckill,\r\n\tNando,\r\n\r\n**csvgrep** printed lines which the regular expression `\"^$\"` didn't match the phone number.\r\nThe trailing spaces in the fields values are removed before it's processed, so blank spaced fields are empty for **csvgrep**.\r\n\r\nEvery column declare as a reference in one rule is printed, but sometimes it's interesting to omit that column from the output.\r\nIt can be done using the expression function `@hide`.\r\n\r\n\t$ csvgrep '@header $NR == 1; ${Name} ; @hide ${Phone} eq /^$/' contacts.csv \r\n\tJeckill\r\n\tNando\r\n\r\nIn this example we are saying to **csvgrep** to _hide_ the phone column, so it's not sent to the output and only the contacts that have an empty phone number were printed.\r\nWe can stack as many expression as we want and build more sophisticated queries\r\n\r\n\t$ csvgrep '@header $NR == 1; ${Name} ; ${Phone} ne /^$/ ; @hide ${Email} eq \"@popstar\" ; @hide ${Notes} eq \"tattoo\"' contacts.csv\r\n\tRafaela,676-9876\r\n\r\n---\r\n\r\nIn some cases it is useful to find contents inside a list and for this task we have the `in` operator.\r\n\r\n\t$ csvgrep '@header $NR == 1; ${IM} in \"rafa lolo manu laura ana joana\" ; ${Name} ; ${Phone}' contacts.csv\r\n\tlolo,Lorie Cabucio,555-5435\r\n\trafa,Rafaela,676-9876\r\n\r\nit could also be done with a regular expression\r\n\r\n\t$ csvgrep '@header $NR == 1; ${IM} eq \"rafa|lolo|manu|laura|ana|joana\" ; ${Name} ; ${Phone}' contacts.csv\r\n\tlolo,Lorie Cabucio,555-5435\r\n\trafa,Rafaela,676-9876\r\n\r\nThe `in` operator is most useful when applied to search for a content into a file.\r\n\r\n\t$ csvgrep '@header $NR == 1; ${IM} in `cat names.txt` ; ${Name} ; ${Phone}' contacts.csv\r\n\tlolo,Lorie Cabucio,555-5435\r\n\trafa,Rafaela,676-9876\r\n\r\n\r\nwhere\r\n\r\n\t$ cat names.txt \r\n\trafa\r\n\tlolo\r\n\tmanu\r\n\tlaura\r\n\tana\r\n\r\nThe string delimited by the grave accent is executed as a shell command and its output text is used as text into the expression value.\r\n\r\n---\r\n\r\nLet's take a look at another file.\r\n\r\n\tDate,Open,High,Low,Close,Volume,Adj Close\r\n\t2008-11-17,1494.74,1526.96,1481.70,1482.05,1831540000,1482.05\r\n\t2008-11-14,1560.59,1587.76,1513.09,1516.85,2243750000,1516.85\r\n\t2008-11-13,1503.06,1596.70,1428.54,1596.70,3009550000,1596.70\r\n\t...\r\n\t1971-02-09,100.76,100.76,100.76,100.76,000,100.76\r\n\t1971-02-08,100.84,100.84,100.84,100.84,000,100.84\r\n\t1971-02-05,100.00,100.00,100.00,100.00,000,100.00\r\n\r\nThis files was downloaded from [Yahoo Finance](http://finance.yahoo.com) and it has the stock values of some company.\r\nThe dates range from 05/02/1971 to 11/17/2008 and we want to find the dates where the Close price has broken the $1000 level.\r\n\r\n\t$ csvgrep '@header $NR == 1 ; $NR ; ${Date} ; ${Close} >= 999 ; @hide ${Close} <= 1001' table1.csv\r\n\t3344,1995-08-10,1000.61\r\n\t3355,1995-07-26,1000.18\r\n\t3363,1995-07-14,999.33\r\n\r\nWe can see the on date 07/14/1995 the Close price was very close to $1000.\r\n\r\nOne important thing to mention about operators that handle numeric operands is the coercion rules:\r\n\r\n1. the column's content comes as text.\r\n1. the text is coerced to a number following Perl's coercion engine: any text that doesn't represents a number values 0.\r\n1. Missing fields are empty strings, so in a numeric context it values 0.\r\n\r\nLet's suppose now that we want get all points after the break of $1000.\r\nWe saw that the break had occurred approximately on 07/14/1995, so we can get all data after this date.\r\nThis date is in the line number 3363, so as the data is listed with decreasing date, we want all lines with `$NR` less than 3363:\r\n\r\n\t$ csvgrep '@header $NR == 1 ; $NR <= 3363 ; ${Date} ; ${Close}' table1.csv\r\n\t2,2008-11-17,1482.05\r\n\t3,2008-11-14,1516.85\r\n\t4,2008-11-13,1596.70\r\n\t5,2008-11-12,1499.21\r\n\t...\r\n\t3360,1995-07-19,952.87\r\n\t3361,1995-07-18,988.53\r\n\t3362,1995-07-17,1005.89\r\n\t3363,1995-07-14,999.33\r\n\r\nthe line number is the first field at the output, to hide it use `@hide` within the first rule.\r\n\r\n<!-- \r\n- - -\r\n\r\nThe reference `$#N` values the length of the text referred by `$N`. -->\r\n\r\n---\r\n\r\nA simple way to quickly evaluate a field regarding whether or not it has a valid content is using the question mark reference `$?N` or `$?{.}`.\r\n\r\n\t$ csvgrep -aN '' bool.csv \r\n\t1:Zero,0.0\r\n\t2:Minus Zero,-0.0\r\n\t3:False,false\r\n\t4:True,true\r\n\t5:One,1\r\n\t6:One Decimal,1.0\r\n\t7:Minus One Decimal,-1.0\r\n\t8:Empty,\r\n\t\r\n\t$ csvgrep '$NR ; $1 ; $?2' bool.csv \r\n\t4,True,true\r\n\t5,One,1\r\n\t6,One Decimal,1.0\r\n\t7,Minus One Decimal,-1.0\r\n\t\r\n\t$ csvgrep '$NR ; $?1 ; $2' bool.csv \r\n\t1,Zero,0.0\r\n\t2,Minus Zero,-0.0\r\n\t4,True,true\r\n\t5,One,1\r\n\t6,One Decimal,1.0\r\n\t7,Minus One Decimal,-1.0\r\n\t8,Empty,\r\n\r\nAs we can see all fields with\r\n\r\n- 0.0\r\n- false (ignoring case)\r\n- /^$/ (empty)\r\n\r\nwere evaluated to false.\r\n\r\nPay attention to the first command, it uses the option `-N` to print the line numbers.\r\n\r\n---\r\n\r\nFor checking whether the number of fields remains constant in the file respecting the defined header or not, we have the option `-C` that returns 0 for the shell in case of success or 2 in case of failure indicating that at some point into the file the number of fields is different from the number of columns defined by the header.\r\n\r\n\t$ csvgrep -C '@header $NR == 1' table1.csv\r\n\t\r\n\t$ echo $?\r\n\t0\r\n\t\r\n\t$ csvgrep -C '@header $NR == 1' table2.csv \r\n\t\r\n\t$ echo $?\r\n\t2\r\n\t\r\n\t$ cat table2.csv \r\n\tDate,Open,High,Low,Close,Volume,Adj Close\r\n\t2008-11-17,1494.74,1526.96,1481.70,1482.05,1831540000,1482.05\r\n\t2008-11-14,1560.59,1587.76,1513.09,1516.85\r\n\r\n---\r\n\r\nSometimes it is useful to put a delimiter at the end of each line sent to output.\r\nThe option `-c`, close-line command, solves that problem.\r\n\r\n\t$ csvgrep -c -O':' '@header $NR == 1; ${Name} ; ${Phone} ne \"^$\"' contacts.csv \r\n\tWilson:555-5555:\r\n\tLorie Cabucio:555-5435:\r\n\tRafaela:676-9876:\r\n\tAndrea Martins:576-0912:\r\n\r\n---\r\n\r\nAs seen before, when the field contains a delimiter it is printed surrounded with quotation marks.\r\nIn order to have that field unquoted we should use the option `-u` (unquote).\r\n\r\n\t$ csvgrep -a '' quoted.csv \r\n\tName,Comment\r\n\tHyde,\"The guy who didn't sleep, do you believe\"\r\n\tLoren,\"The power, the strength, the energy what was left to us\"\r\n\t\r\n\t$ csvgrep -au '' quoted.csv \r\n\tName,Comment\r\n\tHyde,The guy who didn't sleep, do you believe\r\n\tLoren,The power, the strength, the energy what was left to us\r\n\r\n---\r\n\r\nThough its simplicity **csvgrep** makes a great job solving some well defined problems when handling with structured files.\r\nI will continue looking forward to find ways to improve **csvgrep**.","google":"UA-4510606-2","note":"Don't delete this file! It's used internally to help with page regeneration."}